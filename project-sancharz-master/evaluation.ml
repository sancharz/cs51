(*
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2017
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)
    
open Expr ;;
 
(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;

(* Environments and values *)

module type Env_type = 
sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value =
      Closure ( exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      let (_, y) = (List.find (fun (a, _) -> varname = a) env) in 
       !y 
    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    (* If a variable already exists then replace its value *)
    let extend (env : env) (varname : varid) (loc : value ref) : env =
      try 
       let (_, y) = (List.find (fun (a, _) -> varname = a) env) in 
         y := !loc; 
         env 
      with 
      | Not_found -> (varname, loc) :: env 

    (* mutually recursive helper function to print lists*)
    let rec string_list (x : (varid * value ref) list) : string = 
        match x with
        | [] -> ""
        | (a, b ) :: l -> a ^ " -> " ^ 
                          (value_to_string !b) ^ 
                          " ; " ^ (string_list l) 
                          
    and value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with 
      | Val e -> (exp_to_string e)
      | Closure (ex , en) -> if printenvp 
                             then  "( " ^ (exp_to_string ex) ^ ",  [" ^ 
                                  (string_list en) ^ "]" ^ " )"      
                             else exp_to_string ex

   (* Returns a printable string representation of an environment *)
   let env_to_string (env : env) : string =
     "[ " ^ string_list env ^ "]" 

  end
;;
  
open Env;;
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)

(* Helper functions for evaluation *)
let binopeval (b : binop) (e1 : expr) (e2 : expr) : expr =
   match b, e1, e2  with 
   | Plus, Num n1, Num n2 -> Num (n1 + n2)
   | Plus, _, _ -> Raise
   | Minus, Num n1, Num n2 -> Num (n1 - n2)
   | Minus, _, _  -> Raise
   | Times, Num n1, Num n2 -> Num (n1 * n2)
   | Times, _, _  -> Raise
   | Equals, Num n1, Num n2 -> Bool (n1 = n2)
   | Equals, Bool b1, Bool b2 -> Bool (b1 = b2)
   | Equals, _, _  -> Raise
   | LessThan, Num n1, Num n2 -> Bool (n1 < n2)
   | LessThan, Bool b1, Bool b2 -> Bool (b1 < b2)
   | LessThan, _, _  -> Raise
;;

let unopeval (u : unop) (e : expr) : expr = 
   match u, e with
   | Negate, Num n -> binopeval Minus (Num 0) (Num n)
   | Negate, _ -> Raise
  ;;

 let environ = Env.create () ;;

let rec eval_s  (exp : expr) (_en : Env.env)  : expr = 
  match exp with
  | Var _x -> Raise                    
  | Num _n ->  exp           
  | Bool _b -> exp           
  | Unop (u, e) ->  unopeval u (eval_s e environ)         
  | Binop (b, e1, e2) -> binopeval b (eval_s e1 environ) (eval_s e2 environ)
  | Conditional (e1, e2, e3) -> (if ((binopeval Equals 
                                    (eval_s e1 environ) 
                                    (Bool true)) = Bool true) 
                               then (eval_s e2 environ) 
                               else (eval_s e3 environ))
  | Fun (v, e) -> Fun(v, e)               
  | Let (v, e1, e2) -> (eval_s (subst v (eval_s e1 environ) e2) environ)
  | Letrec (v, e1, e2) -> (eval_s (subst v 
                          (eval_s (subst v 
                          (Letrec(v, e1, Var v)) e1) environ ) e2) environ) 
  | Raise -> Raise                        
  | Unassigned -> Unassigned 
  | App (e1, e2) ->  (match e1 with 
                     |Fun (v, e) -> (eval_s (subst v 
                                    (eval_s e2 environ) e) environ)
                     | _ -> exp )
;;
(* Environment Semantics  *)
let rec eval_d (exp : expr) (en : Env.env)  : expr =
  match exp with
  | Var x -> (try match (lookup en x) with
                 | Val x -> x
                 | Closure (_ex, _en1) -> Raise 
            with 
            | Not_found -> Raise )                
  | Num _n -> exp           
  | Bool _b -> exp        
  | Unop (u, e) -> unopeval u (eval_d e en)         
  | Binop (b, e1, e2) -> binopeval b (eval_d e1 en) (eval_d e2 en)    
  | Conditional (e1, e2, e3) -> (if ((binopeval Equals 
                                (eval_d e1 en) (Bool true))
                                = Bool true) 
                                then (eval_d e2 en) 
                                else (eval_d e3 en))
  | Fun (_v, _e) -> exp                
  | Let (v, e1, e2) -> eval_d e2 (extend en v (ref (Val (eval_d e1 en))))
  | Letrec (v, e1, e2) -> eval_d e2 (extend en v (ref (Val (eval_d e1 
                                    (extend en v (ref(Val Unassigned))))))) 
  | Raise -> Raise                       
  | Unassigned ->  Unassigned                        
  | App (e1, e2) -> ( match (eval_d e1 en) with
                      | Fun (v, e) -> eval_d e (extend en v 
                                      (ref (Val (eval_d e2 en))))
                      | _ -> Raise)
;;

let rec eval_l (exp : expr) (en : Env.env)  : expr =
  match exp with
  | Var x -> (try match (lookup en x) with
                 | Val x -> x
                 | Closure (_ex, _en1) -> Raise 
            with 
            | Not_found -> Raise )                
  | Num _n -> exp           
  | Bool _b -> exp        
  | Unop (u, e) -> unopeval u (eval_l e en)         
  | Binop (b, e1, e2) -> binopeval b (eval_l e1 en) (eval_l e2 en)    
  | Conditional (e1, e2, e3) -> (if ((binopeval Equals (eval_l e1 en) 
                                    (Bool true))
                                    = Bool true) 
                               then (eval_l e2 en) 
                               else (eval_l e3 en))
  | Fun (_v, _e) -> exp                
  | Let (v, e1, e2) -> eval_l e2 (extend en v (ref (Val (eval_l e1 en))))
  | Letrec (v, e1, e2) -> eval_l e2 (extend en v (ref (Val (eval_l e1 
                                    (extend en v (ref(Val Unassigned)))))))    
  | Raise -> Raise                       
  | Unassigned ->  Unassigned                        
  | App (e1, e2) -> ( match (eval_l e1 en) with
                      | Fun (v, e) -> eval_l e (extend en v 
                                      (ref (Val (eval_l e2 en))))
                      | _ -> Raise)
;;

let eval_t exp _env = exp ;;

let evaluate = eval_s ;;